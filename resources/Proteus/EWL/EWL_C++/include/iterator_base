/* EWL
 * Copyright © 1995-2009 Freescale Corporation.  All rights reserved.
 *
 * $Date: 2012/07/12 22:31:16 $
 * $Revision: 1.3 $
 */

#ifndef _ITERATOR_BASE
#define _ITERATOR_BASE

/*  iterator synopsis

namespace std
{

	//  lib.iterator.primitives, primitives:

template<class Iterator>
struct iterator_traits
{
	typedef typename Iterator::difference_type difference_type;
	typedef typename Iterator::value_type value_type;
	typedef typename Iterator::pointer pointer;
	typedef typename Iterator::reference reference;
	typedef typename Iterator::iterator_category iterator_category;
};

template<class Category, class T, class Distance = ptrdiff_t, class Pointer = T*, class Reference = T&>
struct iterator
{
	typedef T         value_type;
	typedef Distance  difference_type;
	typedef Pointer   pointer;
	typedef Reference reference;
	typedef Category  iterator_category;
};

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag       : public input_iterator_tag {};
struct bidirectional_iterator_tag : public forward_iterator_tag {};
struct random_access_iterator_tag : public bidirectional_iterator_tag {};

	//  lib.iterator.operations, iterator operations:

template <class InputIterator, class Distance>
void
advance(InputIterator& i, Distance n);

template <class InputIterator>
typename iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);

	//  lib.predef.iterators, predefined iterators:

template <class Iterator>
class reverse_iterator
	: public iterator<typename iterator_traits<Iterator>::iterator_category,
	                  typename iterator_traits<Iterator>::value_type,
	                  typename iterator_traits<Iterator>::difference_type,
	                  typename iterator_traits<Iterator>::pointer,
	                  typename iterator_traits<Iterator>::reference>
{
protected:
	Iterator current;
public:
	typedef Iterator iterator_type;
	typedef typename iterator_traits<Iterator>::difference_type difference_type;
	typedef typename iterator_traits<Iterator>::reference reference;
	typedef typename iterator_traits<Iterator>::pointer pointer;

	reverse_iterator();
	explicit reverse_iterator(Iterator x);
	template <class U> reverse_iterator(const reverse_iterator<U>& u);

	Iterator base() const;      //  explicit
	reference operator*() const;
	pointer   operator->() const;

	reverse_iterator& operator++();
	reverse_iterator  operator++(int);
	reverse_iterator& operator--();
	reverse_iterator  operator--(int);

	reverse_iterator  operator+ (difference_type n) const;
	reverse_iterator& operator+=(difference_type n);
	reverse_iterator  operator- (difference_type n) const;
	reverse_iterator& operator-=(difference_type n);
	reference operator[](difference_type n) const;
};

template <class It> bool operator==(const reverse_iterator<It>& x, const reverse_iterator<It>& y);
template <class It> bool operator< (const reverse_iterator<It>& x, const reverse_iterator<It>& y);
template <class It> bool operator!=(const reverse_iterator<It>& x, const reverse_iterator<It>& y);
template <class It> bool operator> (const reverse_iterator<It>& x, const reverse_iterator<It>& y);
template <class It> bool operator>=(const reverse_iterator<It>& x, const reverse_iterator<It>& y);
template <class It> bool operator<=(const reverse_iterator<It>& x, const reverse_iterator<It>& y);

template <class It>
typename reverse_iterator<It>::difference_type
operator-(const reverse_iterator<It>& x, const reverse_iterator<It>& y);

template <class It>
reverse_iterator<It>
operator+(typename reverse_iterator<It>::difference_type n, const reverse_iterator<It>& x);

template <class Container>
class back_insert_iterator
	: public iterator<output_iterator_tag,void,void,void,void>
{
protected:
	Container* container;

public:
	typedef Container container_type;

	explicit back_insert_iterator(Container& x);
	back_insert_iterator& operator=(typename Container::const_reference value);

	back_insert_iterator& operator*();
	back_insert_iterator& operator++();
	back_insert_iterator  operator++(int);
};

template <class Container>
back_insert_iterator<Container>
back_inserter(Container& x);

template <class Container>
class front_insert_iterator
	: public iterator<output_iterator_tag,void,void,void,void>
{
protected:
	Container* container;

public:
	typedef Container container_type;
	explicit front_insert_iterator(Container& x);
	front_insert_iterator& operator=(typename Container::const_reference value);

	front_insert_iterator& operator*();
	front_insert_iterator& operator++();
	front_insert_iterator  operator++(int);
};

template <class Container>
front_insert_iterator<Container>
front_inserter(Container& x);

template <class Container>
class insert_iterator
	: public iterator<output_iterator_tag,void,void,void,void>
{
protected:
	Container* container;
	typename Container::iterator iter;

public:
	typedef Container container_type;
	insert_iterator(Container& x, typename Container::iterator i);
	insert_iterator& operator=(typename Container::const_reference value);

	insert_iterator& operator*();
	insert_iterator& operator++();
	insert_iterator& operator++(int);
};

template <class Container, class Iterator>
insert_iterator<Container>
inserter(Container& x, Iterator i);

}  // std
*/

#include <ewlconfig>

#include <cstddef>
#include <iosfwd>
#include <ewl_utility>
#include <utility>
#include <char_traits>

#ifdef _EWL_DEBUG
	#include <stdexcept>
#endif

#ifdef __CWCC__
#pragma options align=native

#ifdef _EWL_FORCE_ENUMS_ALWAYS_INT
	#if _EWL_FORCE_ENUMS_ALWAYS_INT
		#pragma enumsalwaysint on
	#else
		#pragma enumsalwaysint off
	#endif
#endif  // _EWL_FORCE_ENUMS_ALWAYS_INT

#ifdef _EWL_FORCE_ENABLE_BOOL_SUPPORT
	#if _EWL_FORCE_ENABLE_BOOL_SUPPORT
		#pragma bool on
	#else
		#pragma bool off
	#endif
#endif  // _EWL_FORCE_ENABLE_BOOL_SUPPORT
#endif

#ifdef __GNUC__
extern "C++" {
#endif // __GNUC__

#ifndef _EWL_NO_CPP_NAMESPACE
	namespace std {
#endif

//  lib.iterator.primitives, primitives:

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: public input_iterator_tag {};
struct bidirectional_iterator_tag: public forward_iterator_tag {};
struct random_access_iterator_tag: public bidirectional_iterator_tag {};


template <class T>
struct __is_segmented
{
private:
	struct two {char x; char y;};
	template <class U> static two  test(...);
	template <class U> static char test(typename U::__segmented* = 0);
public:
	static const bool value = sizeof(test<T>(0)) == 1;
};

template <class T>
struct __has_iterator_category
{
	void quiet_gcc();
private:
	struct two {char x; char y;};
	template <class U> static two  test(...);
	template <class U> static char test(typename U::iterator_category* = 0);
public:
	static const bool value = sizeof(test<T>(0)) == 1;
};

#if !defined(__GNUC__) || 1

template <class Iterator, bool>
struct __iterator_traits_helper
{
};

template <class Iterator>
struct __iterator_traits_helper<Iterator, true>
{
	typedef typename Iterator::difference_type   difference_type;
	typedef typename Iterator::value_type        value_type;
	typedef typename Iterator::pointer           pointer;
	typedef typename Iterator::reference         reference;
	typedef typename Iterator::iterator_category iterator_category;
};

template <class Iterator, bool>
struct __iterator_traits
{
};

template <class Iterator>
struct __iterator_traits<Iterator, true>
	:	__iterator_traits_helper
		<
			Iterator,
			CodeWarrior::is_convertible<typename Iterator::iterator_category, input_iterator_tag>::value ||
			CodeWarrior::is_convertible<typename Iterator::iterator_category, output_iterator_tag>::value
		>
{
};

template <class Iterator>
struct iterator_traits
	:  __iterator_traits<Iterator, __has_iterator_category<Iterator>::value>
{
};

#else  // __GNUC__

template<class Iterator>
struct iterator_traits
{
	typedef typename Iterator::difference_type   difference_type;
	typedef typename Iterator::value_type        value_type;
	typedef typename Iterator::pointer           pointer;
	typedef typename Iterator::reference         reference;
	typedef typename Iterator::iterator_category iterator_category;
};

#endif  // __GNUC__

template <class T>
struct iterator_traits<T*>
{
	typedef ptrdiff_t                  difference_type;
	typedef T                          value_type;
	typedef T*                         pointer;
	typedef T&                         reference;
	typedef random_access_iterator_tag iterator_category;
};

template <class T>
struct iterator_traits<const T*>
{
	typedef ptrdiff_t                  difference_type;
	typedef T                          value_type;
	typedef const T*                   pointer;
	typedef const T&                   reference;
	typedef random_access_iterator_tag iterator_category;
};

template<class Category, class T, class Distance = ptrdiff_t,
	class Pointer = T*, class Reference = T&>
struct iterator
{
	typedef T         value_type;
	typedef Distance  difference_type;
	typedef Pointer   pointer;
	typedef Reference reference;
	typedef Category  iterator_category;
};



//#if !defined(__GNUC__) || defined(_GCCPORT_)

// __is_iterator

template <class T>
struct __is_iterator
{
	static const bool value = __has_iterator_category<iterator_traits<T> >::value;
};

// __is_input_iterator

template <bool b, class T>
struct __is_input_iterator_helper
{
	static const bool value = false;
};

template <class T>
struct __is_input_iterator_helper<true, T>
{
	static const bool value =
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, input_iterator_tag>::value;
};

template <class T>
struct __is_input_iterator
{
	static const bool value = __is_input_iterator_helper<__is_iterator<T>::value, T>::value;
};

// __is_output_iterator

template <bool b, class T>
struct __is_output_iterator_helper
{
	static const bool value = false;
};

template <class T>
struct __is_output_iterator_helper<true, T>
{
	static const bool value =
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, output_iterator_tag>::value ||
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, forward_iterator_tag>::value;
};

template <class T>
struct __is_output_iterator
{
	static const bool value = __is_output_iterator_helper<__is_iterator<T>::value, T>::value;
};

// __is_forward_iterator

template <bool b, class T>
struct __is_forward_iterator_helper
{
	static const bool value = false;
};

template <class T>
struct __is_forward_iterator_helper<true, T>
{
	static const bool value =
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, forward_iterator_tag>::value;
};

template <class T>
struct __is_forward_iterator
{
	static const bool value = __is_forward_iterator_helper<__is_iterator<T>::value, T>::value;
};

// __is_bidirectional_iterator

template <bool b, class T>
struct __is_bidirectional_iterator_helper
{
	static const bool value = false;
};

template <class T>
struct __is_bidirectional_iterator_helper<true, T>
{
	static const bool value =
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, bidirectional_iterator_tag>::value;
};

template <class T>
struct __is_bidirectional_iterator
{
	static const bool value = __is_bidirectional_iterator_helper<__is_iterator<T>::value, T>::value;
};

// __is_random_access_iterator

template <bool b, class T>
struct __is_random_access_iterator_helper
{
	static const bool value = false;
};

template <class T>
struct __is_random_access_iterator_helper<true, T>
{
	static const bool value =
		CodeWarrior::is_convertible<typename iterator_traits<T>::iterator_category, random_access_iterator_tag>::value;
};

template <class T>
struct __is_random_access_iterator
{
	static const bool value = __is_random_access_iterator_helper<__is_iterator<T>::value, T>::value;
};

template<class Category, class T, class Distance, class Pointer, class Reference>
struct __is_iterator<iterator<Category, T, Distance, Pointer, Reference> >
{
	static const bool value = false;
};

//#endif  // __GNUC__

//  lib.iterator.operations, iterator operations:

// advance

template <class InputIterator, class Distance>
inline
void
__advance(InputIterator& i, Distance n, input_iterator_tag)
{
	for (; n > 0; --n)
		++i;
}

template <class InputIterator, class Distance>
inline
void
__advance(InputIterator& i, Distance n, input_iterator_tag t, CodeWarrior::int2type<false>)
{
	__advance(i, n, t);
}

template <class BidirectionalIterator, class Distance>
inline
void
__advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag, CodeWarrior::int2type<true>)
{
	if (n >= 0)
		for (; n > 0; --n)
			++i;
	else
		for (; n < 0; ++n)
			--i;
}

template <class BidirectionalIterator, class Distance>
inline
void
__advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag t)
{
	__advance(i, n, t, CodeWarrior::int2type<CodeWarrior::is_signed<Distance>::value>());
}

template <class RandomAccessIterator, class Distance>
inline
void
__advance(RandomAccessIterator& i, Distance n, random_access_iterator_tag)
{
	i += static_cast<typename iterator_traits<RandomAccessIterator>::difference_type>(n);
}

template <class InputIterator, class Distance>
inline
void
advance(InputIterator& i, Distance n)
{
	__advance(i, n, typename iterator_traits<InputIterator>::iterator_category());
}

// distance

template <class InputIterator>
inline
typename iterator_traits<InputIterator>::difference_type
__distance(InputIterator first, InputIterator last, input_iterator_tag)
{
	typename iterator_traits<InputIterator>::difference_type result = 0;
	for (; first != last; ++first)
		++result;
	return result;
}

template <class RandomAccessIterator>
inline
typename iterator_traits<RandomAccessIterator>::difference_type
__distance(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag)
{
	return last - first;
}

template <class InputIterator>
inline
#if !defined(__GNUC__) || 1
typename CodeWarrior::restrict_to
<
	__is_input_iterator<InputIterator>::value,
	typename iterator_traits<InputIterator>::difference_type
>::type
#else  // __GNUC__
typename iterator_traits<InputIterator>::difference_type
#endif
distance(InputIterator first, InputIterator last)
{
	return __distance(first, last, typename iterator_traits<InputIterator>::iterator_category());
}

//  lib.predef.iterators, predefined iterators:

// reverse_iterator

template <class Iterator>
class reverse_iterator
	: public iterator<typename iterator_traits<Iterator>::iterator_category,
	                  typename iterator_traits<Iterator>::value_type,
	                  typename iterator_traits<Iterator>::difference_type,
	                  typename iterator_traits<Iterator>::pointer,
	                  typename iterator_traits<Iterator>::reference>
{
	mutable Iterator tmp_;
protected:
	Iterator current;
public:
	typedef Iterator                                            iterator_type;
	typedef typename iterator_traits<Iterator>::difference_type difference_type;
	typedef typename iterator_traits<Iterator>::reference       reference;
	typedef typename iterator_traits<Iterator>::pointer         pointer;

	reverse_iterator();
	explicit reverse_iterator(Iterator x);
#ifndef _EWL_NO_MEMBER_TEMPLATE
#ifndef _EWL_MUST_INLINE_MEMBER_TEMPLATE
	template <class U> reverse_iterator(const reverse_iterator<U>& u);
#else
	template <class U>
	inline
	reverse_iterator(const reverse_iterator<U>& u)
		: current(u.base())
	{
	}
#endif  // _EWL_MUST_INLINE_MEMBER_TEMPLATE
#endif  // _EWL_NO_MEMBER_TEMPLATE

	template <class U> reverse_iterator& operator=(const reverse_iterator<U>& x)
		{current = x.base(); return *this;}

	Iterator base() const;      //  explicit
	reference operator*() const;
	pointer   operator->() const;

	reverse_iterator& operator++();
	reverse_iterator  operator++(int);
	reverse_iterator& operator--();
	reverse_iterator  operator--(int);

	reverse_iterator  operator+ (difference_type n) const;
	reverse_iterator& operator+=(difference_type n);
	reverse_iterator  operator- (difference_type n) const;
	reverse_iterator& operator-=(difference_type n);
	reference operator[](difference_type n) const;
};

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>::reverse_iterator()
	:	tmp_(),
		current()
{
}

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>::reverse_iterator(BidirectionalIterator x)
	:	tmp_(),
		current(x)
{
}

#ifndef _EWL_NO_MEMBER_TEMPLATE
#ifndef _EWL_MUST_INLINE_MEMBER_TEMPLATE
	template <class BidirectionalIterator>
	template <class U>
	inline
	reverse_iterator<BidirectionalIterator>::reverse_iterator(const reverse_iterator<U>& u)
		:	tmp_(),
			current(u.base())
	{
	}
#endif  // _EWL_MUST_INLINE_MEMBER_TEMPLATE
#endif  // _EWL_NO_MEMBER_TEMPLATE

template <class BidirectionalIterator>
inline
BidirectionalIterator
reverse_iterator<BidirectionalIterator>::base() const
{
	return current;
}

template <class BidirectionalIterator>
inline
typename reverse_iterator<BidirectionalIterator>::reference
reverse_iterator<BidirectionalIterator>::operator*() const
{
	tmp_ = current;
	return *--tmp_;
}

template <class BidirectionalIterator>
inline
typename reverse_iterator<BidirectionalIterator>::pointer
reverse_iterator<BidirectionalIterator>::operator->() const
{
	return &(operator*());
}

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>&
reverse_iterator<BidirectionalIterator>::operator++()
{
	--current;
	return *this;
}

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>
reverse_iterator<BidirectionalIterator>::operator++(int)
{
	reverse_iterator tmp = *this;
	--current;
	return tmp;
}

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>&
reverse_iterator<BidirectionalIterator>::operator--()
{
	++current;
	return *this;
}

template <class BidirectionalIterator>
inline
reverse_iterator<BidirectionalIterator>
reverse_iterator<BidirectionalIterator>::operator--(int)
{
	reverse_iterator tmp = *this;
	++current;
	return tmp;
}

template <class RandomAccessIterator>
inline
reverse_iterator<RandomAccessIterator>
reverse_iterator<RandomAccessIterator>::operator+ (difference_type n) const
{
	return reverse_iterator(current - n);
}

template <class RandomAccessIterator>
inline
reverse_iterator<RandomAccessIterator>
reverse_iterator<RandomAccessIterator>::operator- (difference_type n) const
{
	return reverse_iterator(current + n);
}

template <class RandomAccessIterator>
inline
reverse_iterator<RandomAccessIterator>&
reverse_iterator<RandomAccessIterator>::operator+=(difference_type n)
{
	current -= n;
	return *this;
}

template <class RandomAccessIterator>
inline
reverse_iterator<RandomAccessIterator>&
reverse_iterator<RandomAccessIterator>::operator-=(difference_type n)
{
	current += n;
	return *this;
}

template <class RandomAccessIterator>
inline
typename reverse_iterator<RandomAccessIterator>::reference
reverse_iterator<RandomAccessIterator>::operator[](difference_type n) const
{
	return *(current + (-n-1));
}

template <class BidirectionalIterator1, class BidirectionalIterator2>
inline
bool
operator==(const reverse_iterator<BidirectionalIterator1>& x,
           const reverse_iterator<BidirectionalIterator2>& y)
{
	return static_cast<bool>(x.base() == y.base());
}

template <class RandomAccessIterator1, class RandomAccessIterator2>
inline
bool
operator< (const reverse_iterator<RandomAccessIterator1>& x,
           const reverse_iterator<RandomAccessIterator2>& y)
{
	return static_cast<bool>(x.base() > y.base());
}

template <class BidirectionalIterator1, class BidirectionalIterator2>
inline
bool
operator!=(const reverse_iterator<BidirectionalIterator1>& x,
           const reverse_iterator<BidirectionalIterator2>& y)
{
	return static_cast<bool>(x.base() != y.base());
}

template <class RandomAccessIterator1, class RandomAccessIterator2>
inline
bool
operator> (const reverse_iterator<RandomAccessIterator1>& x,
           const reverse_iterator<RandomAccessIterator2>& y)
{
	return static_cast<bool>(x.base() < y.base());
}

template <class RandomAccessIterator1, class RandomAccessIterator2>
inline
bool
operator>=(const reverse_iterator<RandomAccessIterator1>& x,
           const reverse_iterator<RandomAccessIterator2>& y)
{
	return static_cast<bool>(x.base() <= y.base());
}

template <class RandomAccessIterator1, class RandomAccessIterator2>
inline
bool
operator<=(const reverse_iterator<RandomAccessIterator1>& x,
           const reverse_iterator<RandomAccessIterator2>& y)
{
	return static_cast<bool>(x.base() >= y.base());
}

template <class RandomAccessIterator1, class RandomAccessIterator2>
inline
typename reverse_iterator<RandomAccessIterator1>::difference_type
operator-(const reverse_iterator<RandomAccessIterator1>& x,
          const reverse_iterator<RandomAccessIterator2>& y)
{
	return y.base() - x.base();
}

template <class RandomAccessIterator>
inline
reverse_iterator<RandomAccessIterator>
operator+(typename reverse_iterator<RandomAccessIterator>::difference_type n,
          const reverse_iterator<RandomAccessIterator>& x)
{
	return reverse_iterator<RandomAccessIterator>(x.base() - n);
}

// back_insert_iterator

template <class Container>
class back_insert_iterator
	: public iterator<output_iterator_tag, void, void, void, void>
{
protected:
	Container* container;

public:
	typedef Container container_type;
	typedef typename CodeWarrior::add_reference<
		typename Container::const_reference const>::type const_reference;

	explicit back_insert_iterator(Container& x);
	back_insert_iterator& operator=(const_reference value);
#ifdef _EWL_MOVE
	back_insert_iterator& operator=(typename Container::value_type&& value)
		{container->push_back(_STD::move(value)); return *this;}
#endif  // _EWL_MOVE

	back_insert_iterator& operator*();
	back_insert_iterator& operator++();
	back_insert_iterator& operator++(int);
};

template <class Container>
inline
back_insert_iterator<Container>::back_insert_iterator(Container& x)
	: container(&x)
{
}

template <class Container>
inline
back_insert_iterator<Container>&
back_insert_iterator<Container>::operator=(const_reference value)
{
	container->push_back(value);
	return *this;
}

template <class Container>
inline
back_insert_iterator<Container>&
back_insert_iterator<Container>::operator*()
{
	return *this;
}

template <class Container>
inline
back_insert_iterator<Container>&
back_insert_iterator<Container>::operator++()
{
	return *this;
}

template <class Container>
inline
back_insert_iterator<Container>&
back_insert_iterator<Container>::operator++(int)
{
	return *this;
}

template <class Container>
inline
back_insert_iterator<Container>
back_inserter(Container& x)
{
	return back_insert_iterator<Container>(x);
}

// front_insert_iterator

template <class Container>
class front_insert_iterator
	: public iterator<output_iterator_tag, void, void, void, void>
{
protected:
	Container* container;

public:
	typedef Container container_type;
	typedef typename CodeWarrior::add_reference<
		typename Container::const_reference const>::type const_reference;

	explicit front_insert_iterator(Container& x);
	front_insert_iterator& operator=(const_reference value);
#ifdef _EWL_MOVE
	front_insert_iterator& operator=(typename Container::value_type&& value)
		{container->push_front(_STD::move(value)); return *this;}
#endif  // _EWL_MOVE

	front_insert_iterator& operator*();
	front_insert_iterator& operator++();
	front_insert_iterator& operator++(int);
};

template <class Container>
inline
front_insert_iterator<Container>::front_insert_iterator(Container& x)
	: container(&x)
{
}

template <class Container>
inline
front_insert_iterator<Container>&
front_insert_iterator<Container>::operator=(const_reference value)
{
	container->push_front(value);
	return *this;
}

template <class Container>
inline
front_insert_iterator<Container>&
front_insert_iterator<Container>::operator*()
{
	return *this;
}

template <class Container>
inline
front_insert_iterator<Container>&
front_insert_iterator<Container>::operator++()
{
	return *this;
}

template <class Container>
inline
front_insert_iterator<Container>&
front_insert_iterator<Container>::operator++(int)
{
	return *this;
}

template <class Container>
inline
front_insert_iterator<Container>
front_inserter(Container& x)
{
	return front_insert_iterator<Container>(x);
}

// insert_iterator

template <class Container>
class insert_iterator
	: public iterator<output_iterator_tag, void, void, void, void>
{
protected:
	Container* container;
	typename Container::iterator iter;
	typedef typename CodeWarrior::add_reference<
		typename Container::const_reference const>::type const_reference;

public:
	typedef Container container_type;
	insert_iterator(Container& x, typename Container::iterator i);
	insert_iterator& operator=(const_reference value);
#ifdef _EWL_MOVE
	insert_iterator& operator=(typename Container::value_type&& value)
		{iter = container->insert(iter, _STD::move(value)); ++iter; return *this;}
#endif  // _EWL_MOVE

	insert_iterator& operator*();
	insert_iterator& operator++();
	insert_iterator& operator++(int);
};

template <class Container>
inline
insert_iterator<Container>::insert_iterator(Container& x, typename Container::iterator i)
	: container(&x),
	  iter(i)
{
}

template <class Container>
inline
insert_iterator<Container>&
insert_iterator<Container>::operator=(const_reference value)
{
	iter = container->insert(iter, value);
	++iter;
	return *this;
}

template <class Container>
inline
insert_iterator<Container>&
insert_iterator<Container>::operator*()
{
	return *this;
}

template <class Container>
inline
insert_iterator<Container>&
insert_iterator<Container>::operator++()
{
	return *this;
}

template <class Container>
inline
insert_iterator<Container>&
insert_iterator<Container>::operator++(int)
{
	return *this;
}

#if !defined(__CWCC__) || (defined(__CWCC__) && __CWCC__ >= 0x2400)

	template <class Container, class Iterator>
	inline
	insert_iterator<Container>
	inserter(Container& x, Iterator i)
	{
		return insert_iterator<Container>(x, typename Container::iterator(i));
	}

#else  // !defined(__CWCC__) || (defined(__CWCC__) && __CWCC__ >= 0x2400)

	template <class Container, class Iterator>
	inline
	insert_iterator<Container>
	inserter(Container& x, Iterator i)
	{
		return insert_iterator<Container>(x, Container::iterator(i));
	}

#endif  // !defined(__CWCC__) || (defined(__CWCC__) && __CWCC__ >= 0x2400)

template <class To, class From>
struct __implicit_convert
{
	typedef To   to;
	typedef From from;
	typedef typename iterator_traits<to>::value_type value_type;
	value_type operator () (const from& f) const {return *f;}
};

template <class To, class From>
class __reinterpret_convert
{
public:
	typedef To   to;
	typedef From from;
private:
	template <bool b> struct chooser {};
	typedef typename iterator_traits<from>::reference reference;
	typedef typename iterator_traits<from>::value_type fvalue_type;
	typedef typename iterator_traits<to>::value_type tvalue_type;
public:
	tvalue_type operator () (from f) const
	#if defined(__CWCC__) || defined(__GNUC__)
		{return cast(f, chooser<CodeWarrior::is_reference<__typeof__(*f)>::value>());}
	#else
		{return cast(f, chooser<CodeWarrior::is_reference<reference>::value>());}
	#endif
private:
	tvalue_type cast(from f, chooser<true>) const
		{return *(tvalue_type*)(&*f);}
	tvalue_type cast(from f, chooser<false>) const
		{fvalue_type tmp = *f; return *(tvalue_type*)(&tmp);}
};

template <class Cast>
class __convert_iterator
{
public:
	typedef typename Cast::to to;
	typedef typename Cast::from from;
	typedef typename iterator_traits<from>::iterator_category iterator_category;
	typedef typename iterator_traits<to>::value_type          value_type;
	typedef typename iterator_traits<from>::difference_type   difference_type;
	typedef void                                              pointer;
	typedef value_type                                        reference;

	explicit __convert_iterator(const from& i) : i_(i) {}

	value_type operator*() const {return c_(i_);}

	__convert_iterator& operator++() {++i_; return *this;}
	__convert_iterator  operator++(int) {__convert_iterator tmp(*this); operator++(); return tmp;}
	__convert_iterator& operator--() {--i_; return *this;}
	__convert_iterator  operator--(int) {__convert_iterator tmp(*this); operator--(); return tmp;}

	__convert_iterator& operator+=(difference_type n) {i_ += n; return *this;}
	__convert_iterator  operator+ (difference_type n) const {return __convert_iterator(*this) += n;}

	__convert_iterator& operator-=(difference_type n) {i_ -= n; return *this;}
	__convert_iterator  operator- (difference_type n) const {return __convert_iterator(*this) -= n;}

	difference_type operator-(const __convert_iterator& y) const
	{
		return i_ - y.i_;
	}

	value_type operator[](difference_type n) const {return i_[n];}

	bool operator==(const __convert_iterator& y) const
	{ return i_ == y.i_; }

	bool operator!=(const __convert_iterator& y) const
	{ return !(*this == y); }

	bool operator< (const __convert_iterator& y) const
	{ return i_ <  y.i_; }

	bool operator<= (const __convert_iterator& y) const
	{ return !(y.i_ <  i_); }

	bool operator> (const __convert_iterator& y) const
	{ return y.i_ <  i_; }

	bool operator>= (const __convert_iterator& y) const
	{ return !(i_ <  y.i_); }

private:
	from i_;
	Cast c_;
};

namespace detail
{

template <class T>
struct __is_convert_iterator
{
	static const bool value = false;
};

template <class Cast>
struct __is_convert_iterator<__convert_iterator<Cast> >
{
	static const bool value = true;
};

} // namespace detail

template <class ConvertIterator>
inline 
typename CodeWarrior::restrict_to<
	detail::__is_convert_iterator<ConvertIterator>::value, 
	ConvertIterator
>::type
operator+(typename ConvertIterator::difference_type n,
          const ConvertIterator& x)
{
	return x + n;
}

template <class Container, class Iterator>
class __wrap_iterator
{
public:
	typedef typename iterator_traits<Iterator>::value_type value_type;
	typedef typename iterator_traits<Iterator>::difference_type difference_type;
	typedef typename iterator_traits<Iterator>::pointer pointer;
	typedef typename iterator_traits<Iterator>::reference reference;
	typedef typename iterator_traits<Iterator>::iterator_category iterator_category;

	__wrap_iterator() {}
	template <class OtherIterator>
		__wrap_iterator(const __wrap_iterator<Container, OtherIterator>& i,
			typename CodeWarrior::restrict_to<CodeWarrior::is_convertible<OtherIterator, Iterator>::value>::type* = 0) : it_(i.it_) {};

	reference operator * () const {return *it_;}
	Iterator operator -> () const  {return it_;}

	__wrap_iterator& operator++() {++it_; return *this;}
	__wrap_iterator operator++(int) {__wrap_iterator tmp(*this); operator++(); return tmp;}
	__wrap_iterator& operator--() {--it_; return *this;}
	__wrap_iterator operator--(int) {__wrap_iterator tmp(*this); operator--(); return tmp;}

	__wrap_iterator& operator+=(difference_type n) {it_ += n; return *this;}
	__wrap_iterator operator+(difference_type n) const {return __wrap_iterator(*this) += n;}
	reference operator [] (difference_type i) const {return *(*this + i);}

	__wrap_iterator& operator-=(difference_type n) {return operator+=(-n);}
	__wrap_iterator operator-(difference_type n) const {return __wrap_iterator(*this) -= n;}

	Iterator base() const {return it_;}
private:
#ifdef _EWL_NO_TEMPLATE_FRIENDS
public:
#endif
	Iterator it_;
#ifdef _EWL_NO_TEMPLATE_FRIENDS
private:
#endif
#ifndef _EWL_NO_TEMPLATE_FRIENDS
	template <class OtherIterator> friend class __wrap_iterator<Container, OtherIterator>;
#endif

public:
	explicit __wrap_iterator(const Iterator& i) : it_(i) {}
	__wrap_iterator(const Container*, const Iterator& i) : it_(i) {}

#ifndef _EWL_NO_TEMPLATE_FRIENDS
	friend class Container::__self;
#endif // _EWL_NO_TEMPLATE_FRIENDS
};

template <class Container, class Iterator>
inline
__wrap_iterator<Container, Iterator>
operator + (typename __wrap_iterator<Container, Iterator>::difference_type n, const __wrap_iterator<Container, Iterator>& y)
{
	return __wrap_iterator<Container, Iterator>(y) += n;
}

template <class Container, class I1, class I2>
inline
typename Container::difference_type
operator -(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return typename Container::difference_type(x.base() - y.base());
}

template <class Container, class I1, class I2>
inline
bool operator ==(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return x.base() == y.base();
}

template <class Container, class I1>
inline
bool operator ==(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return x.base() == y.base();
}

template <class Container, class I1, class I2>
inline
bool operator !=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return !(x == y);
}

template <class Container, class I1>
inline
bool operator !=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return !(x == y);
}

template <class Container, class I1, class I2>
inline
bool operator <(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return x.base() < y.base();
}

template <class Container, class I1>
inline
bool operator <(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return x.base() < y.base();
}

template <class Container, class I1, class I2>
inline
bool operator <=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return !(y < x);
}

template <class Container, class I1>
inline
bool operator <=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return !(y < x);
}

template <class Container, class I1, class I2>
inline
bool operator >(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return y < x;
}

template <class Container, class I1>
inline
bool operator >(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return y < x;
}

template <class Container, class I1, class I2>
inline
bool operator >=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I2>& y)
{
	return !(x < y);
}

template <class Container, class I1>
inline
bool operator >=(const __wrap_iterator<Container, I1>& x, const __wrap_iterator<Container, I1>& y)
{
	return !(x < y);
}

//#if !defined(__GNUC__) || defined(_GCCPORT_)
template <class Iterator,
	bool is_segmented = __is_segmented<typename CodeWarrior::remove_reference<Iterator>::type>::value>

class __move_iterator
{
public:
	typedef typename CodeWarrior::remove_reference<Iterator>::type           iterator_type;
	typedef typename _STD::iterator_traits<iterator_type>::difference_type   difference_type;
	typedef typename _STD::iterator_traits<iterator_type>::pointer           pointer;
	typedef typename _STD::iterator_traits<iterator_type>::value_type        value_type;
	typedef typename _STD::iterator_traits<iterator_type>::iterator_category iterator_category;
#ifdef _EWL_MOVE
	typedef value_type&&                                               reference;
#else
	typedef value_type&                                                reference;
#endif

	__move_iterator() {}
	explicit __move_iterator(Iterator i) : i_(i) {}
	template <class U> __move_iterator(const __move_iterator<U>& u) : i_(u.base()) {}

	iterator_type base() const {return i_;}
	reference operator*() const {return *i_;}
	pointer   operator->() const {return i_;}

	__move_iterator& operator++() {++i_; return *this;}
	__move_iterator<iterator_type>  operator++(int) {__move_iterator<iterator_type> tmp(*this); ++(*this); return tmp;}
	__move_iterator& operator--() {--i_; return *this;}
	__move_iterator<iterator_type>  operator--(int) {__move_iterator<iterator_type> tmp(*this); --(*this); return tmp;}

	__move_iterator<iterator_type>  operator+ (difference_type n) const {return __move_iterator<iterator_type>(i_ + n);}
	__move_iterator& operator+=(difference_type n) {i_ += n; return *this;}
	__move_iterator<iterator_type>  operator- (difference_type n) const {return __move_iterator<iterator_type>(i_ - n);}
	__move_iterator& operator-=(difference_type n) {i_ -= n; return *this;}
	reference operator[](difference_type n) const {return i_[n];}
private:
	Iterator i_;
};
//#else //__GNUC__
//#endif //__GNUC_

template <class Iterator>
class __move_iterator<Iterator, true>
{
public:
	typedef int __segmented;
	typedef typename CodeWarrior::remove_reference<Iterator>::type           iterator_type;
	typedef typename _STD::iterator_traits<iterator_type>::difference_type   difference_type;
	typedef typename _STD::iterator_traits<iterator_type>::pointer           pointer;
	typedef typename _STD::iterator_traits<iterator_type>::value_type        value_type;
	typedef typename _STD::iterator_traits<iterator_type>::iterator_category iterator_category;
#ifdef _EWL_MOVE
	typedef value_type&&                                               reference;
#else
	typedef value_type&                                                reference;
#endif

	__move_iterator() {}
	explicit __move_iterator(Iterator i) : i_(i) {}
	template <class U> __move_iterator(const __move_iterator<U>& u) : i_(u.base()) {}

	iterator_type base() const {return i_;}
	reference operator*() const {return *i_;}
	pointer   operator->() const {return i_;}

	__move_iterator& operator++() {++i_; return *this;}
	__move_iterator  operator++(int) {__move_iterator tmp(*this); ++(*this); return tmp;}
	__move_iterator& operator--() {--i_; return *this;}
	__move_iterator  operator--(int) {__move_iterator tmp(*this); --(*this); return tmp;}

	__move_iterator  operator+ (difference_type n) const {return __move_iterator(i_ + n);}
	__move_iterator& operator+=(difference_type n) {i_ += n; return *this;}
	__move_iterator  operator- (difference_type n) const {return __move_iterator(i_ - n);}
	__move_iterator& operator-=(difference_type n) {i_ -= n; return *this;}
	reference operator[](difference_type n) const {return i_[n];}

	bool __same_segment(const __move_iterator& x) const
		{return i_.__same_segment(x.i_);}
	__move_iterator<pointer> __begin() const {return __move_iterator<pointer>(i_.__begin());}
	__move_iterator<pointer> __cur() const {return __move_iterator<pointer>(i_.__cur());}
	__move_iterator<pointer&> __ref() {return __move_iterator<pointer&>(i_.__ref());}
	__move_iterator<pointer> __end() const {return __move_iterator<pointer>(i_.__end());}
private:
	Iterator i_;
};

template <class Iterator>
inline
bool
operator==(const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() == y.base());
}

template <class Iterator>
inline
bool
operator!=(const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() != y.base());
}

template <class Iterator>
inline
bool
operator< (const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() < y.base());
}

template <class Iterator>
inline
bool
operator<=(const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() <= y.base());
}

template <class Iterator>
inline
bool
operator> (const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() > y.base());
}

template <class Iterator>
inline
bool
operator>=(const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return static_cast<bool>(x.base() >= y.base());
}

template <class Iterator>
inline
typename __move_iterator<Iterator>::difference_type
operator-(const __move_iterator<Iterator>& x, const __move_iterator<Iterator>& y)
{
	return x.base() - y.base();
}

template <class Iterator>
inline
__move_iterator<Iterator>
operator+(typename __move_iterator<Iterator>::difference_type n, const __move_iterator<Iterator>& x)
{
	return __move_iterator<Iterator>(x.base() + n);
}

template <class Iterator>
inline
__move_iterator<Iterator>
__make_move_iterator(const Iterator& i)
{
	return __move_iterator<Iterator>(i);
}

#ifdef _EWL_DEBUG

template <class Container, class Iterator, bool relax = false>
class __debug_iterator
{
public:
	typedef typename iterator_traits<Iterator>::value_type value_type;
	typedef typename iterator_traits<Iterator>::difference_type difference_type;
	typedef typename iterator_traits<Iterator>::pointer pointer;
	typedef typename iterator_traits<Iterator>::reference reference;
	typedef typename iterator_traits<Iterator>::iterator_category iterator_category;

	__debug_iterator() : owner_(0), next_(0) {}
	__debug_iterator(const __debug_iterator& i);
	template <class OtherIterator>
		__debug_iterator(const __debug_iterator<Container, OtherIterator, relax>& i,
			typename CodeWarrior::restrict_to<CodeWarrior::is_convertible<OtherIterator, Iterator>::value>::type* = 0);
	~__debug_iterator();
	__debug_iterator& operator = (const __debug_iterator& i);

	reference operator * () const {deref(); return *it_;}
	Iterator operator -> () const  {deref(); return it_;}

	__debug_iterator& operator++() {relax_deref("EWL DEBUG: increment end or invalid iterator"); ++it_; return *this;}
	__debug_iterator operator++(int) {__debug_iterator tmp(*this); operator++(); return tmp;}
	__debug_iterator& operator--() {not_begin(); --it_; return *this;}
	__debug_iterator operator--(int) {__debug_iterator tmp(*this); operator--(); return tmp;}

	__debug_iterator& operator+=(difference_type n);
	__debug_iterator operator+(difference_type n) const {return __debug_iterator(*this) += n;}
	reference operator [] (difference_type i) const {return *(*this + i);}

	__debug_iterator& operator-=(difference_type n) {return operator+=(-n);}
	__debug_iterator operator-(difference_type n) const {return __debug_iterator(*this) -= n;}

	Iterator base() const {return it_;}
	template <class OtherIterator>
		void same_owner(const __debug_iterator<Container, OtherIterator, relax>& i) const;
	bool is_invalidated() const {return owner_ == 0;}
private:
#ifdef _EWL_NO_TEMPLATE_FRIENDS
public:
#endif
	Iterator it_;
	Container* owner_;
#ifdef _EWL_NO_TEMPLATE_FRIENDS
private:
#endif
	__debug_iterator* next_;

	__debug_iterator(const Container* c, const Iterator& i);

	template <class Predicate> void remove(Predicate pred);
	template <class Predicate> void add(Container* owner, Predicate pred);
	static void swap(Container* x, Container* y);
	void add(Container* owner);

	void not_begin() const;
	void deref() const;
	void relax_deref(const char* msg) const;

	friend class Container::__self;
#ifndef _EWL_NO_TEMPLATE_FRIENDS
	template <class OtherIterator> friend class __debug_iterator<Container, OtherIterator, relax>;
#endif
};

template <class Container, class Iterator, bool relax>
inline
__debug_iterator<Container, Iterator, relax>::__debug_iterator(const __debug_iterator& i)
	: it_(i.it_), owner_(0), next_(0)
{
	add(i.owner_);
}

template <class Container, class Iterator, bool relax>
template <class OtherIterator>
inline
__debug_iterator<Container, Iterator, relax>::__debug_iterator(const __debug_iterator<Container, OtherIterator, relax>& i,
			typename CodeWarrior::restrict_to<CodeWarrior::is_convertible<OtherIterator, Iterator>::value>::type*)
	: it_(i.it_), owner_(0), next_(0)
{
	add(i.owner_);
}

template <class Container, class Iterator, bool relax>
inline
__debug_iterator<Container, Iterator, relax>::__debug_iterator(const Container* c, const Iterator& i)
	: it_(i), owner_(0), next_(0)
{
	add(const_cast<Container*>(c));
}

template <class Container, class Iterator, bool relax>
inline
__debug_iterator<Container, Iterator, relax>::~__debug_iterator()
{
	add(0);
}

template <class Container, class Iterator, bool relax>
__debug_iterator<Container, Iterator, relax>&
__debug_iterator<Container, Iterator, relax>::operator =(const __debug_iterator& i)
{
	if (this != &i)
	{
		it_ = i.it_;
		add(i.owner_);
	}
	return *this;
}

template <class Container, class Iterator, bool relax>
__debug_iterator<Container, Iterator, relax>&
__debug_iterator<Container, Iterator, relax>::operator+=(difference_type n)
{
	if (owner_ == 0)
		_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: iterator += n on invalid iterator");
	if (n >= 0)
	{
		if (n > ((Container const*)owner_)->__uncheck_end() - it_)
			_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: iterator += n is out of range");
	}
	else
	{
		if (-n > it_ - ((Container const*)owner_)->__uncheck_begin())
			_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: iterator += n is out of range");
	}
	it_ += n;
	return *this;
}

template <class Container, class Iterator, bool relax>
template <class Predicate>
void
__debug_iterator<Container, Iterator, relax>::remove(Predicate pred)
{
	__debug_iterator* p = 0;
	__debug_iterator* n = owner_->template iterator_list<__debug_iterator>();
	while (n)
	{
		if (pred(n->it_))
		{
			if (p == 0)
			{
				n->owner_->template iterator_list<__debug_iterator>() = p = n->next_;
				n->next_ = 0;
				n->owner_ = 0;
				n = p;
				p = 0;
			}
			else
			{
				p->next_ = n->next_;
				n->next_ = 0;
				n->owner_ = 0;
				n = p->next_;
			}
		}
		else
		{
			p = n;
			n = n->next_;
		}
	}
}

template <class Container, class Iterator, bool relax>
template <class Predicate>
void
__debug_iterator<Container, Iterator, relax>::add(Container* owner, Predicate pred)
{
	__debug_iterator* p = 0;
	__debug_iterator* n = this;
	while (n)
	{
		if (pred(n->it_))
		{
			if (p == 0)
			{
				n->owner_->template iterator_list<__debug_iterator>() = p = n->next_;
				n->next_ = 0;
				n->owner_ = 0;
				n->add(owner);
				n = p;
				p = 0;
			}
			else
			{
				p->next_ = n->next_;
				n->next_ = 0;
				n->owner_ = 0;
				n->add(owner);
				n = p->next_;
			}
		}
		else
		{
			p = n;
			n = n->next_;
		}
	}
}

template <class Container, class Iterator, bool relax>
void
__debug_iterator<Container, Iterator, relax>::swap(Container* x, Container* y)
{
	__debug_iterator* nx = x->template iterator_list<__debug_iterator>();
	__debug_iterator* ny = y->template iterator_list<__debug_iterator>();
	y->template iterator_list<__debug_iterator>() = nx;
	x->template iterator_list<__debug_iterator>() = ny;
	while (nx)
	{
		nx->owner_ = y;
		nx = nx->next_;
	}
	while (ny)
	{
		ny->owner_ = x;
		ny = ny->next_;
	}
}

template <class Container, class Iterator, bool relax>
void
__debug_iterator<Container, Iterator, relax>::add(Container* owner)
{
	if (owner_ != owner)
	{
		if (owner_)
		{
			__debug_iterator* p = 0;
			for (__debug_iterator* i = owner_->template iterator_list<__debug_iterator>(); i != this; i = i->next_)
				p = i;
			if (p)
				p->next_ = next_;
			else
				owner_->template iterator_list<__debug_iterator>() = next_;
			owner_ = 0;
		}
		owner_ = owner;
		if (owner_)
		{
			next_ = owner_->template iterator_list<__debug_iterator>();
			owner_->template iterator_list<__debug_iterator>() = this;
		}
	}
}

template <class Container, class Iterator, bool relax>
template <class OtherIterator>
inline
void
__debug_iterator<Container, Iterator, relax>::same_owner(const __debug_iterator<Container, OtherIterator, relax>& i) const
{
	if (owner_ == 0 || i.owner_ == 0 || owner_ != i.owner_)
		_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: comparison of iterators not pointing to the same container");
}

template <class Container, class Iterator, bool relax>
void
__debug_iterator<Container, Iterator, relax>::not_begin() const
{
	if (owner_ == 0 || it_ == ((Container const*)owner_)->__uncheck_begin())
		_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: decrement of invalid or begin() iterator");
}

template <class Container, class Iterator, bool relax>
void
__debug_iterator<Container, Iterator, relax>::deref() const
{
	if (owner_ == 0 || it_ == ((Container const*)owner_)->__uncheck_end())
		_EWL_DEBUG_ERROR(logic_error, "EWL DEBUG: dereferenced invalid iterator");
}

template <class Container, class Iterator, bool relax>
void
__debug_iterator<Container, Iterator, relax>::relax_deref(const char* msg) const
{
	if (relax)
	{
		if (owner_ == 0)
			_EWL_DEBUG_ERROR(logic_error, msg);
	}
	else
	{
		if (owner_ == 0 || it_ == ((Container const*)owner_)->__uncheck_end())
			_EWL_DEBUG_ERROR(logic_error, msg);
	}
}

template <class Container, class Iterator, bool relax>
__debug_iterator<Container, Iterator, relax>
operator + (typename __debug_iterator<Container, Iterator, relax>::difference_type n, const __debug_iterator<Container, Iterator, relax>& y)
{
	return __debug_iterator<Container, Iterator, relax>(y) += n;
}

template <class Container, class I1, class I2, bool relax>
typename Container::difference_type
operator -(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	x.same_owner(y);
	return typename Container::difference_type(x.base() - y.base());
}

template <class Container, class I1, class I2, bool relax>
bool operator ==(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	x.same_owner(y);
	return x.base() == y.base();
}

template <class Container, class I1, class I2, bool relax>
inline
bool operator !=(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	return !(x == y);
}

template <class Container, class I1, class I2, bool relax>
bool operator <(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	x.same_owner(y);
	return x.base() < y.base();
}

template <class Container, class I1, class I2, bool relax>
inline
bool operator <=(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	return !(y < x);
}

template <class Container, class I1, class I2, bool relax>
inline
bool operator >(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	return y < x;
}

template <class Container, class I1, class I2, bool relax>
inline
bool operator >=(const __debug_iterator<Container, I1, relax>& x, const __debug_iterator<Container, I2, relax>& y)
{
	return !(x < y);
}

#endif // _EWL_DEBUG

#ifndef _EWL_NO_CPP_NAMESPACE
	} // namespace std
#endif

#ifdef __GNUC__
} // extern "C++"
#endif // __GNUC__

#ifdef __CWCC__

#ifdef _EWL_FORCE_ENUMS_ALWAYS_INT
	#pragma enumsalwaysint reset
#endif

#ifdef _EWL_FORCE_ENABLE_BOOL_SUPPORT
	#pragma bool reset
#endif

#pragma options align=reset

#endif //__CWCC__

#endif // _ITERATOR_BASE
